// Generated by CoffeeScript 1.7.1
(function() {
  var BezierPath, ControlPoint, LineSegment, Point,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.BezierCurveEditor = (function() {
    function BezierCurveEditor(curveEditorContainer, curveChannels, sendHandler, widthHeight) {
      var each, each2, type;
      this.curveEditorContainer = curveEditorContainer;
      this.curveChannels = curveChannels;
      this.sendHandler = sendHandler;
      this.widthHeight = widthHeight;
      this.getMousePosition = __bind(this.getMousePosition, this);
      this.CubicN = __bind(this.CubicN, this);
      this.getCubicBezierXYatPercent = __bind(this.getCubicBezierXYatPercent, this);
      this.render = __bind(this.render, this);
      this.saveGesture = __bind(this.saveGesture, this);
      this.showGesture = __bind(this.showGesture, this);
      this.showEnvelope = __bind(this.showEnvelope, this);
      this.addGestures = __bind(this.addGestures, this);
      this.listWithCurves = {};
      this.gCanvas;
      this.gCtx;
      this.gBackCanvas;
      this.gBackCtx;
      this.Mode = {
        kAdding: {
          value: 0,
          name: "Adding"
        },
        kSelecting: {
          value: 1,
          name: "Selecting"
        },
        kDragging: {
          value: 2,
          name: "Dragging"
        },
        kRemoving: {
          value: 3,
          name: "Removing"
        }
      };
      this.curveMode;
      this.gState;
      this.gBackgroundImg;
      this.gestures = [];
      for (each in this.curveChannels) {
        this.listWithCurves[this.curveChannels[each][0]] = {
          color: this.curveChannels[each][1],
          gBezierPath: new BezierPath(this.curveChannels[each][0], this),
          bigListWithAllPoints: [],
          listWithAllPoints: []
        };
      }
      this.curveMode = _.keys(this.listWithCurves)[0];
      $("#" + this.curveEditorContainer).html(_.template($("#curve-editor-template").html(), {
        width: this.widthHeight[0],
        height: this.widthHeight[1],
        name: this.curveEditorContainer
      }));
      $('.button-button').button();
      if (_.keys(this.listWithCurves).length > 1) {
        for (type in this.listWithCurves) {
          $("#" + this.curveEditorContainer + " .curve_mode_container").append(" <label> <input type=\"radio\" name=\"curve_mode\" value=\"" + type + "\" " + (type === this.curveMode ? "checked=\"checked\"" : "") + " /> " + type + "</label>");
        }
      }
      this.gCanvas = $("#" + this.curveEditorContainer + " .paintme").get(0);
      this.gCtx = this.gCanvas.getContext("2d");
      this.height = this.gCanvas.height;
      this.width = this.gCanvas.width;
      this.gBackCanvas = $("<canvas class='back-canvas'></canvas>").appendTo($("#" + this.curveEditorContainer)).get(0);
      this.gBackCanvas.height = this.height;
      this.gBackCanvas.width = this.width;
      this.gBackCtx = this.gBackCanvas.getContext("2d");
      this.gState = this.Mode.kAdding;
      $("#" + this.curveEditorContainer + " .paintme").on("mousedown", (function(_this) {
        return function(e) {
          var deleted, handleDownSelect, pos;
          handleDownSelect = function(pos) {
            var selected;
            selected = _this.listWithCurves[_this.curveMode].gBezierPath.selectPoint(pos);
            if (selected) {
              _this.gState = _this.Mode.kDragging;
              _this.gCanvas.addEventListener("mousemove", (function(e) {
                pos = _this.getMousePosition(e);
                _this.listWithCurves[_this.curveMode].gBezierPath.updateSelected(pos);
                return _this.render();
              }), false);
              return true;
            }
            return false;
          };
          pos = _this.getMousePosition(e);
          switch (_this.gState) {
            case _this.Mode.kAdding:
              if (handleDownSelect(pos)) {
                return;
              }
              _this.listWithCurves[_this.curveMode].gBezierPath.addPoint(pos);
              return _this.render();
            case _this.Mode.kSelecting:
              return handleDownSelect(pos);
            case _this.Mode.kRemoving:
              deleted = _this.listWithCurves[_this.curveMode].gBezierPath.deletePoint(pos);
              if (deleted) {
                return _this.render();
              }
          }
        };
      })(this));
      $("#" + this.curveEditorContainer + " .paintme").on("mouseup", (function(_this) {
        return function(e) {
          if (_this.gState === _this.Mode.kDragging) {
            _this.listWithCurves[_this.curveMode].gBezierPath.clearSelected();
            return _this.gState = _this.Mode.kSelecting;
          }
        };
      })(this));
      $("#" + this.curveEditorContainer + " .selectMode").on("click", (function(_this) {
        return function() {
          return _this.gState = _this.Mode.kSelecting;
        };
      })(this));
      $("#" + this.curveEditorContainer + " .addMode").on("click", (function(_this) {
        return function() {
          return _this.gState = _this.Mode.kAdding;
        };
      })(this));
      $("#" + this.curveEditorContainer + " .removeMode").on("click", (function(_this) {
        return function() {
          return _this.gState = _this.Mode.kRemoving;
        };
      })(this));
      $("#" + this.curveEditorContainer + " input[name=curve_mode]").on("change", (function(_this) {
        return function(e) {
          return _this.curveMode = $(e.currentTarget).val();
        };
      })(this));
      $("#" + this.curveEditorContainer + " .test_gesture_ems").on("click", (function(_this) {
        return function() {
          var list;
          list = {};
          for (type in _this.listWithCurves) {
            list[type] = _this.listWithCurves[type].bigListWithAllPoints;
          }
          return _this.sendHandler.send(["gesture", "test", JSON.stringify(list).replace(/,/g, "ยง"), $(".time_for_gesture_test").val()]);
        };
      })(this));
      $("#" + this.curveEditorContainer + " .save_envelope_button").on("click", (function(_this) {
        return function() {
          var allPoints, gestureData, list, new_stuff, send_id;
          list = [];
          for (type in _this.listWithCurves) {
            list.push(_this.listWithCurves[type].bigListWithAllPoints);
          }
          allPoints = JSON.stringify(list[0]).replace(/,/g, "ยง");
          gestureData = _this.saveGesture();
          send_id = _this.curveEditorContainer;
          new_stuff = true;
          if ($("#" + _this.curveEditorContainer).data("envelope-id")) {
            send_id = $("#" + _this.curveEditorContainer).data("envelope-id");
            new_stuff = false;
          }
          return _this.sendHandler.send(["envelope", "save", window.current_user_id, send_id, $("#" + _this.curveEditorContainer + " .envelope_gestures").val(), $("#" + _this.curveEditorContainer + " .gesture_time_duration").val(), allPoints, gestureData, new_stuff]);
        };
      })(this));
      $("#" + this.curveEditorContainer + " .save_gesture_button").on("click", (function(_this) {
        return function() {
          var action, allPoints, data, gestureData, list;
          list = {};
          for (type in _this.listWithCurves) {
            list[type] = _this.listWithCurves[type].bigListWithAllPoints;
          }
          allPoints = JSON.stringify(list).replace(/,/g, "ยง");
          gestureData = _this.saveGesture();
          action = "save";
          data = $("#" + _this.curveEditorContainer + " .saved_gestures").val();
          if ($("#" + _this.curveEditorContainer + " .saved_gestures").val() === "new_gesture") {
            action = "save_new";
            data = $(".save_gesture").val();
          }
          $("#" + _this.curveEditorContainer + " .save_gesture").val("");
          return _this.sendHandler.send(["gesture", action, window.current_user_id, data, allPoints, gestureData]);
        };
      })(this));
      $("#" + this.curveEditorContainer + " .saved_gestures").on("change", (function(_this) {
        return function(e) {
          if ($(e.currentTarget).val() === "new_gesture") {
            $("#" + _this.curveEditorContainer + " .save_gesture_input_container").show();
            return $("#" + _this.curveEditorContainer + " .remove-gesture").hide();
          } else {
            $("#" + _this.curveEditorContainer + " .save_gesture_input_container").hide();
            $("#" + _this.curveEditorContainer + " .remove-gesture").show();
            if (window.default_user === window.current_user_id) {
              $("#" + _this.curveEditorContainer + " .remove-gesture").html("Remove gesture");
            } else {
              $("#" + _this.curveEditorContainer + " .remove-gesture").html("Remove user-specific gesture");
            }
            return _this.sendHandler.send(["gesture", "get", $(e.currentTarget).val()]);
          }
        };
      })(this));
      $("#" + this.curveEditorContainer + " .reset-points").on("click", (function(_this) {
        return function() {
          if (confirm("are you sure you want to delete all?")) {
            return _this.reset();
          }
        };
      })(this));
      for (each2 in this.listWithCurves) {
        this.listWithCurves[each2].gBezierPath.addPoint(new Point(2, this.height - 2));
        this.listWithCurves[each2].gBezierPath.addPoint(new Point(this.width - 2, this.height - 2));
      }
      this.render();
    }

    BezierCurveEditor.prototype.addGestures = function(newGestures, clear) {
      var each, eachh, _results;
      if (clear !== undefined) {
        this.gestures = [];
        if (window.default_user === window.current_user_id) {
          $("#" + this.curveEditorContainer + " .saved_gestures,#" + this.curveEditorContainer + " .envelope_gestures").html("<option value=\"new_gesture\">New gesture</option>");
          $("#" + this.curveEditorContainer + " .save_gesture_input_container").show();
        } else {
          $("#" + this.curveEditorContainer + " .saved_gestures,#" + this.curveEditorContainer + " .envelope_gestures").html("<option>Select gesture</option>");
          $("#" + this.curveEditorContainer + " .save_gesture_input_container").hide();
        }
      }
      for (eachh in newGestures) {
        this.gestures.push(newGestures[eachh]);
      }
      _results = [];
      for (each in this.gestures) {
        _results.push($("#" + this.curveEditorContainer + " .saved_gestures,#" + this.curveEditorContainer + " .envelope_gestures").append("<option value=\"" + this.gestures[each]['_id']['$oid'] + "\">" + this.gestures[each]['name'] + "</option>"));
      }
      return _results;
    };

    BezierCurveEditor.prototype.reset = function() {
      var each, each2;
      for (each in this.curveChannels) {
        this.listWithCurves[this.curveChannels[each][0]] = {
          color: this.curveChannels[each][1],
          gBezierPath: new BezierPath(this.curveChannels[each][0], this),
          bigListWithAllPoints: [],
          listWithAllPoints: []
        };
      }
      for (each2 in this.listWithCurves) {
        this.listWithCurves[each2].gBezierPath.addPoint(new Point(2, this.height - 2));
        this.listWithCurves[each2].gBezierPath.addPoint(new Point(this.width - 2, this.height - 2));
      }
      return this.render();
    };

    BezierCurveEditor.prototype.showEnvelope = function(id, gesture, duration, individualPoints) {
      var each, type;
      $("#" + this.curveEditorContainer + " .envelope_gestures").val(gesture);
      $("#" + this.curveEditorContainer + " .gesture_time_duration").val(duration);
      for (type in this.listWithCurves) {
        for (each in this.listWithCurves[type].listWithAllPoints) {
          this.listWithCurves[type].gBezierPath.deletePoint(this.listWithCurves[type].listWithAllPoints[each].pt);
        }
      }
      for (type in this.listWithCurves) {
        this.listWithCurves[type].listWithAllPoints = [];
        this.listWithCurves[type].bigListWithAllPoints = [];
      }
      for (each in individualPoints) {
        this.listWithCurves[individualPoints[each][3]].gBezierPath.addPoint(new Point(individualPoints[each][0][0], individualPoints[each][0][1]));
      }
      return this.render();
    };

    BezierCurveEditor.prototype.showGesture = function(id, data) {
      var each, type;
      if ($("#" + this.curveEditorContainer + " .saved_gestures").val() === id) {
        for (type in this.listWithCurves) {
          for (each in this.listWithCurves[type].listWithAllPoints) {
            this.listWithCurves[type].gBezierPath.deletePoint(this.listWithCurves[type].listWithAllPoints[each].pt);
          }
        }
        for (type in this.listWithCurves) {
          this.listWithCurves[type].listWithAllPoints = [];
          this.listWithCurves[type].bigListWithAllPoints = [];
        }
        for (each in data) {
          this.listWithCurves[data[each][3]].gBezierPath.addPoint(new Point(data[each][0][0], data[each][0][1]));
        }
        return this.render();
      }
    };

    BezierCurveEditor.prototype.saveGesture = function() {
      var allSegments, each, type;
      allSegments = [];
      for (type in this.listWithCurves) {
        for (each in this.listWithCurves[type].listWithAllPoints) {
          allSegments.push(this.listWithCurves[type].listWithAllPoints[each].stringify());
        }
      }
      return JSON.stringify(allSegments).replace(/,/g, "ยง");
    };

    BezierCurveEditor.prototype.render = function() {
      var a, ctrlPt1, ctrlPt2, each, endPt, first, i, listByX, startPt, type, values, width, x, x_val, y, y_val;
      this.gBackCtx.clearRect(0, 0, this.width, this.height);
      this.gCtx.clearRect(0, 0, this.width, this.height);
      x = 0.5;
      while (x < this.width) {
        this.gCtx.moveTo(x, 0);
        this.gCtx.lineTo(x, this.height);
        x += this.width / 30;
      }
      y = 0.5;
      while (y < this.height) {
        this.gCtx.moveTo(0, y);
        this.gCtx.lineTo(this.width, y);
        y += this.height / 30;
      }
      this.gCtx.strokeStyle = "#ddd";
      this.gCtx.stroke();
      if (this.gBackgroundImg) {
        this.gBackCtx.drawImage(this.gBackgroundImg, 0, 0);
      }
      for (each in this.listWithCurves) {
        this.listWithCurves[each].gBezierPath.draw(this.gBackCtx);
      }
      this.gCtx.drawImage(this.gBackCanvas, 0, 0);
      for (type in this.listWithCurves) {
        this.listWithCurves[type].bigListWithAllPoints = [];
      }
      for (type in this.listWithCurves) {
        first = true;
        for (each in this.listWithCurves[type].listWithAllPoints) {
          if (!first) {
            width = 600;
            i = 0;
            while (i < width) {
              startPt = this.listWithCurves[type].listWithAllPoints[each].prev.pt;
              ctrlPt1 = this.listWithCurves[type].listWithAllPoints[each].ctrlPt1;
              ctrlPt2 = this.listWithCurves[type].listWithAllPoints[each].ctrlPt2;
              endPt = this.listWithCurves[type].listWithAllPoints[each].pt;
              a = this.getCubicBezierXYatPercent(startPt, ctrlPt1, ctrlPt2, endPt, i / width);
              listByX = [];
              x_val = Math.round(a.x);
              y_val = 100 - (Math.round(a.y * 100 / this.height));
              if (x_val >= 0 && x_val < 600) {
                if (this.listWithCurves[type].bigListWithAllPoints[x_val]) {
                  this.listWithCurves[type].bigListWithAllPoints[x_val] = Math.round((this.listWithCurves[type].bigListWithAllPoints[x_val] + y_val) / 2);
                } else {
                  this.listWithCurves[type].bigListWithAllPoints[x_val] = y_val;
                }
              }
              i++;
            }
          } else {
            first = false;
          }
        }
      }
      for (type in this.listWithCurves) {
        i = 2;
        while (i < width) {
          if (!this.listWithCurves[type].bigListWithAllPoints[i] || this.listWithCurves[type].bigListWithAllPoints[i] === 0) {
            values = [];
            if (this.listWithCurves[type].bigListWithAllPoints[i - 1] < 100) {
              values.push(this.listWithCurves[type].bigListWithAllPoints[i - 1]);
            }
            if (this.listWithCurves[type].bigListWithAllPoints[i + 1] < 100) {
              values.push(this.listWithCurves[type].bigListWithAllPoints[i + 1]);
            }
            this.listWithCurves[type].bigListWithAllPoints[i] = Math.round(values.reduce((function(_this) {
              return function(p, c) {
                return p + c;
              };
            })(this)) / values.length);
          }
          i++;
        }
        this.listWithCurves[type].bigListWithAllPoints[0] = 0;
        this.listWithCurves[type].bigListWithAllPoints[1] = 0;
      }
    };

    BezierCurveEditor.prototype.getCubicBezierXYatPercent = function(startPt, controlPt1, controlPt2, endPt, percent) {
      var x, y;
      x = this.CubicN(percent, startPt.x(), controlPt1.x(), controlPt2.x(), endPt.x());
      y = this.CubicN(percent, startPt.y(), controlPt1.y(), controlPt2.y(), endPt.y());
      return {
        x: x,
        y: y
      };
    };

    BezierCurveEditor.prototype.CubicN = function(pct, a, b, c, d) {
      var t2, t3;
      t2 = pct * pct;
      t3 = t2 * pct;
      return a + (-a * 3 + pct * (3 * a - a * pct)) * pct + (3 * b + pct * (-6 * b + b * 3 * pct)) * pct + (c * 3 - c * 3 * pct) * t2 + d * t3;
    };

    BezierCurveEditor.prototype.getMousePosition = function(e) {
      var x, y;
      x = void 0;
      y = void 0;
      if (e.pageX !== undefined && e.pageY !== undefined) {
        x = e.pageX;
        y = e.pageY;
      } else {
        x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }
      x -= this.gCanvas.offsetLeft;
      y -= this.gCanvas.offsetTop;
      return new Point(x, y);
    };

    return BezierCurveEditor;

  })();

  Point = function(newX, newY) {
    var RADIUS, SELECT_RADIUS, my, startXVal, xVal, yVal;
    my = this;
    xVal = newX;
    yVal = newY;
    startXVal = function() {
      return newX();
    };
    RADIUS = 3;
    SELECT_RADIUS = RADIUS + 2;
    this.x = function() {
      return xVal;
    };
    this.y = function() {
      return yVal;
    };
    this.startX = function() {
      return startXVal;
    };
    this.set = function(x, y) {
      xVal = x;
      return yVal = y;
    };
    this.drawSquare = function(ctx) {
      return ctx.fillRect(xVal - RADIUS, yVal - RADIUS, RADIUS * 2, RADIUS * 2);
    };
    this.computeSlope = function(pt) {
      return (pt.y() - yVal) / (pt.x() - xVal);
    };
    this.contains = function(pt) {
      var xInRange, yInRange;
      xInRange = pt.x() >= xVal - SELECT_RADIUS && pt.x() <= xVal + SELECT_RADIUS;
      yInRange = pt.y() >= yVal - SELECT_RADIUS && pt.y() <= yVal + SELECT_RADIUS;
      return xInRange && yInRange;
    };
    this.offsetFrom = function(pt) {
      return {
        xDelta: pt.x() - xVal,
        yDelta: pt.y() - yVal
      };
    };
    this.translate = function(xDelta, yDelta) {
      xVal += xDelta;
      return yVal += yDelta;
    };
    return this;
  };

  ControlPoint = function(angle, magnitude, owner, isFirst) {
    var computeMagnitudeAngleFromOffset, my, origin, updateNeighbor, _angle, _isFirst, _magnitude, _owner;
    computeMagnitudeAngleFromOffset = function(xDelta, yDelta) {
      var tryAngle, _angle, _magnitude;
      _magnitude = Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2));
      tryAngle = Math.atan(yDelta / xDelta);
      if (!isNaN(tryAngle)) {
        _angle = tryAngle;
        if (xDelta < 0) {
          _angle += Math.PI;
        }
      }
    };
    updateNeighbor = function() {
      var neighbor;
      neighbor = null;
      if (_isFirst && _owner.prev) {
        neighbor = _owner.prev.ctrlPt2;
      } else {
        if (!_isFirst && _owner.next) {
          neighbor = _owner.next.ctrlPt1;
        }
      }
      if (neighbor) {
        neighbor.setAngle(_angle + Math.PI);
      }
    };
    my = this;
    _angle = angle;
    _magnitude = magnitude;
    _owner = owner;
    _isFirst = isFirst;
    this.setAngle = function(deg) {
      if (_angle !== deg) {
        return _angle = deg;
      }
    };
    this.origin = origin = function() {
      var line;
      line = null;
      if (_isFirst) {
        line = _owner.prev;
      } else {
        line = _owner;
      }
      if (line) {
        return new Point(line.pt.x(), line.pt.y());
      }
      return null;
    };
    this.asPoint = function() {
      return new Point(my.x(), my.y());
    };
    this.x = function() {
      return my.origin().x() + my.xDelta();
    };
    this.y = function() {
      return my.origin().y() + my.yDelta();
    };
    this.xDelta = function() {
      return _magnitude * Math.cos(_angle);
    };
    this.yDelta = function() {
      return _magnitude * Math.sin(_angle);
    };
    this.translate = function(xDelta, yDelta) {
      var dist, newLoc;
      newLoc = my.asPoint();
      newLoc.translate(xDelta, yDelta);
      dist = my.origin().offsetFrom(newLoc);
      computeMagnitudeAngleFromOffset(dist.xDelta, dist.yDelta);
      if (my.__proto__.syncNeighbor) {
        return updateNeighbor();
      }
    };
    this.contains = function(pt) {
      return my.asPoint().contains(pt);
    };
    this.offsetFrom = function(pt) {
      return my.asPoint().offsetFrom(pt);
    };
    this.draw = function(ctx) {
      var endPt, startPt;
      ctx.save();
      ctx.fillStyle = "gray";
      ctx.strokeStyle = "gray";
      ctx.beginPath();
      startPt = my.origin();
      endPt = my.asPoint();
      ctx.moveTo(startPt.x(), startPt.y());
      ctx.lineTo(endPt.x(), endPt.y());
      ctx.stroke();
      endPt.drawSquare(ctx);
      return ctx.restore();
    };
    updateNeighbor();
    return this;
  };

  LineSegment = function(pt, prev, channel, these) {
    var drawCurve, init, my;
    drawCurve = function(ctx, startPt, endPt, ctrlPt1, ctrlPt2) {
      ctx.save();
      ctx.fillStyle = these.listWithCurves[my.channel].color;
      ctx.strokeStyle = these.listWithCurves[my.channel].color;
      ctx.beginPath();
      ctx.moveTo(startPt.x(), startPt.y());
      ctx.bezierCurveTo(ctrlPt1.x(), ctrlPt1.y(), ctrlPt2.x(), ctrlPt2.y(), endPt.x(), endPt.y());
      ctx.lineWidth = 10;
      ctx.stroke();
      return ctx.restore();
    };
    init = function() {
      var angle, slope;
      my.pt = pt;
      my.prev = prev;
      my.channel = channel;
      if (my.prev) {
        slope = my.pt.computeSlope(my.prev.pt);
        angle = Math.atan(slope);
        if (my.prev.pt.x() > my.pt.x()) {
          angle *= -1;
        }
        my.ctrlPt1 = new ControlPoint(10 * Math.PI, 10 * Math.PI, my, true);
        return my.ctrlPt2 = new ControlPoint(10 * Math.PI, 10 * Math.PI, my, false);
      }
    };
    my = this;
    these = these;
    this.channel;
    this.pt;
    this.ctrlPt1;
    this.ctrlPt2;
    this.next;
    this.prev;
    this.selectedPoint;
    init();
    this.stringify = function() {
      var c1, c2, p;
      p = null;
      c1 = null;
      c2 = null;
      if (this.pt != null) {
        p = [this.pt.x(), this.pt.y()];
      }
      if (this.ctrlPt1 != null) {
        c1 = [this.ctrlPt1.x(), this.ctrlPt1.y()];
      }
      if (this.ctrlPt2 != null) {
        c2 = [this.ctrlPt2.x(), this.ctrlPt2.y()];
      }
      return [p, c1, c2, this.channel];
    };
    this.draw = function(ctx) {
      my.pt.drawSquare(ctx);
      if (my.ctrlPt1) {
        my.ctrlPt1.draw(ctx);
      }
      if (my.ctrlPt2) {
        my.ctrlPt2.draw(ctx);
      }
      if (my.prev) {
        drawCurve(ctx, my.prev.pt, my.pt, my.ctrlPt1, my.ctrlPt2);
      }
    };
    this.findInLineSegment = function(pos) {
      if (my.pathPointIntersects(pos)) {
        my.selectedPoint = my.pt;
        return true;
      } else if (my.ctrlPt1 && my.ctrlPt1.contains(pos)) {
        my.selectedPoint = my.ctrlPt1;
        return true;
      } else if (my.ctrlPt2 && my.ctrlPt2.contains(pos)) {
        my.selectedPoint = my.ctrlPt2;
        return true;
      }
      return false;
    };
    this.pathPointIntersects = function(pos) {
      return my.pt && my.pt.contains(pos);
    };
    this.moveTo = function(pos) {
      var dist, xx;
      dist = my.selectedPoint.offsetFrom(pos);
      if (my.selectedPoint.x() !== 2 && my.selectedPoint.x() !== these.width - 2) {
        return my.selectedPoint.translate(dist.xDelta, dist.yDelta);
      } else {
        xx = (my.selectedPoint.x() === 2 ? 2 : these.width - 2);
        return my.selectedPoint.translate(0, dist.yDelta);
      }
    };
    return this;
  };

  BezierPath = function(channel, these) {
    var my;
    my = this;
    these = these;
    my.channel = channel;
    this.channel;
    this.head = null;
    this.tail = null;
    this.selectedSegment;
    this.addPoint = function(pt) {
      var each, _results;
      for (each in these.listWithCurves[my.channel].listWithAllPoints) {
        my.deletePoint(these.listWithCurves[my.channel].listWithAllPoints[each].pt);
      }
      if (pt.x() >= 0 && pt.x() < 600) {
        these.listWithCurves[my.channel].listWithAllPoints[pt.x()] = {
          pt: pt
        };
      }
      _results = [];
      for (each in these.listWithCurves[my.channel].listWithAllPoints) {
        _results.push(these.listWithCurves[my.channel].listWithAllPoints[each] = my.addPointOrg(these.listWithCurves[my.channel].listWithAllPoints[each].pt));
      }
      return _results;
    };
    this.addPointOrg = function(pt) {
      var newPt;
      newPt = new LineSegment(pt, my.tail, my.channel, these);
      if (my.tail == null) {
        my.tail = newPt;
        my.head = newPt;
      } else {
        my.tail.next = newPt;
        my.tail = my.tail.next;
      }
      return newPt;
    };
    this.draw = function(ctx) {
      var current, _results;
      if (my.head == null) {
        return;
      }
      current = my.head;
      _results = [];
      while (current != null) {
        current.draw(ctx);
        _results.push(current = current.next);
      }
      return _results;
    };
    this.selectPoint = function(pos) {
      var current;
      current = my.head;
      while (current != null) {
        if (current.findInLineSegment(pos)) {
          this.selectedSegment = current;
          return true;
        }
        current = current.next;
      }
      return false;
    };
    this.deletePoint = function(pos) {
      var current, leftNeighbor, rightNeighbor, toDelete;
      current = my.head;
      while (current != null) {
        if (current.pathPointIntersects(pos)) {
          toDelete = current;
          leftNeighbor = current.prev;
          rightNeighbor = current.next;
          if (leftNeighbor && rightNeighbor) {
            leftNeighbor.next = rightNeighbor;
            rightNeighbor.prev = leftNeighbor;
          } else if (!leftNeighbor) {
            my.head = rightNeighbor;
            if (my.head) {
              rightNeighbor.ctrlPt1 = null;
              rightNeighbor.ctrlPt2 = null;
              my.head.prev = null;
            } else {
              my.tail = null;
            }
          } else if (!rightNeighbor) {
            my.tail = leftNeighbor;
            if (my.tail) {
              my.tail.next = null;
            } else {
              my.head = null;
            }
          }
          return true;
        }
        current = current.next;
      }
      return false;
    };
    this.clearSelected = function() {
      return this.selectedSegment = null;
    };
    this.updateSelected = function(pos) {
      return this.selectedSegment.moveTo(pos);
    };
    return this;
  };

  window.keyboardShortcuts = function(ws) {
    var keyAllowed;
    keyAllowed = {};
    $(document).on("keydown", function(e) {
      var button_value, selectedObject, stuff;
      if (!keyAllowed[e.which]) {
        keyAllowed[e.which] = true;
        stuff = String.fromCharCode(event.keyCode).toLowerCase();
        if (/^[1-9]+$/i.test(stuff)) {
          selectedObject = $("#muscle_controller [data-shortkey=" + String.fromCharCode(event.keyCode).toLowerCase() + "]");
          if (selectedObject.data("button-value")) {
            $("#muscle_controller .speed_control").removeClass("active");
          }
        }
        if (/^[a-z1-9]+$/i.test(stuff)) {
          selectedObject = $("#muscle_controller [data-shortkey=" + String.fromCharCode(event.keyCode).toLowerCase() + "]");
          button_value = selectedObject.data("button-value");
          if (button_value) {
            selectedObject.addClass("active");
            ws.send(["muscle_control", button_value, true]);
          }
        }
        if (e.which === 13) {
          $("#run_button").trigger("click");
        }
        if (e.which === 48 || e.which === 189 || e.which === 187 || e.which === 219 || e.which === 221) {
          selectedObject = $("#muscle_controller [data-shortkey=" + stuff + "]");
          selectedObject.addClass("active");
          console.log(selectedObject.data("button-value"));
          return ws.send(["muscle_control", selectedObject.data("button-value"), true]);
        }
      }
    });
    $(document).on("keyup", function(e) {
      var button_value, selectedObject, stuff;
      keyAllowed[e.which] = false;
      stuff = String.fromCharCode(event.keyCode).toLowerCase();
      if (/^[a-z]+$/i.test(stuff)) {
        selectedObject = $("#muscle_controller [data-shortkey=" + String.fromCharCode(event.keyCode).toLowerCase() + "]");
        button_value = selectedObject.data("button-value");
        if (button_value) {
          selectedObject.removeClass("active");
          ws.send(["muscle_control", button_value, false]);
        }
      }
      if (e.which === 48 || e.which === 189 || e.which === 187 || e.which === 219 || e.which === 221) {
        return $("#muscle_controller [data-shortkey=" + stuff + "]").removeClass("active");
      }
    });
    $("#muscle_controller button").on("mousedown", function() {
      var val;
      $("#muscle_controller .speed_control").removeClass("active");
      $(this).addClass("active");
      val = $(this).data("button-value");
      return ws.send(["muscle_control", val, true]);
    });
    $("#muscle_controller button").on("mouseup", function() {
      var val;
      $(this).removeClass("active");
      val = $(this).data("button-value");
      return ws.send(["muscle_control", val, false]);
    });
    $("#muscle_controller [data-shortkey=1]").addClass("active");
    return ws.send(["muscle_control", "1", true]);
  };

}).call(this);
